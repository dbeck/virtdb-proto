#include "log_record.hh"

namespace virtdb { namespace logger {
  
  // the last item in the list
  log_record::sender::sender(const end_msg &,
                             log_record::sender * parent)
  : record_(parent->record_),
    root_(parent->root_),
    pb_data_ptr_(nullptr)
  {
    assert( root_ != nullptr );
    if( root_ && root_->pb_record_ )
    {
      auto sink = log_sink::get_sptr();
      if( sink )
        sink->send_record(root_->pb_record_);
    }
  }
  
  // return from scoped message
  log_record::sender::sender(const end_msg &,
                             const log_record * record)
  : record_(record),
    root_(this),
    pb_record_(new interface::pb::LogRecord),
    pb_data_ptr_(nullptr)
  {
    prepare_record();
    
    {
      assert( record_ != nullptr );
      if( record_ )
      {
        auto data_array = pb_record_->mutable_data();
        pb_data_ptr_ = data_array->Add();
        pb_data_ptr_->set_headerseqno(record_->id());
        pb_data_ptr_->set_elapsedmicrosec(util::relative_time::instance().get_usec());
        std::hash<std::thread::id> hash_fn;
        std::size_t thr_hash = hash_fn(std::this_thread::get_id());        
        pb_data_ptr_->set_threadid(static_cast<uint64_t>(thr_hash));
        pb_data_ptr_->set_endscope(true);
      }
    }
    
    // pb_record_ must be set by prepare_record
    assert( root_ != nullptr );
    if( root_ && root_->pb_record_ )
    {
      auto sink = log_sink::get_sptr();
      if( sink )
        sink->send_record(root_->pb_record_);
    }
  }
  
  // iterating over the last item
  log_record::sender
  log_record::sender::operator<<(const end_msg & v)
  {
    return log_record::sender(v, this);
  }
  
  void log_record::sender::prepare_record()
  {
    {
      auto process = pb_record_->mutable_process();
      process->MergeFrom(process_info::instance().get_pb());
    }
    
    {
      uint32_t last_sent = symbol_store::max_id_sent();
      if( symbol_store::has_more(last_sent) )
      {
        auto symbols = pb_record_->mutable_symbols();
        symbol_store::for_each( [&last_sent,symbols](const std::string & symbol_str,
                                                     uint32_t symbol_id) {
          auto symbol = symbols->Add();
          symbol->set_seqno(symbol_id);
          symbol->set_value(symbol_str);
          last_sent = symbol_id;
          return true;
        }, last_sent);
        symbol_store::max_id_sent(last_sent);
      }
    }
    
    {
      assert( record_ != nullptr );
      if( record_ )
      {
        if( !header_store::header_sent(record_->id()) )
        {
          auto headers = pb_record_->mutable_headers();
          auto header_item = headers->Add();
          header_item->MergeFrom(record_->get_pb_header());
          header_store::header_sent(record_->id(),true);
        }
      }
    }
  }

  log_record::log_record(const char *             file,
                         uint32_t                 line,
                         const char *             func,
                         log_level                level,
                         bool                     enabled,
                         const signature::part &  part,
                         const signature &        sig,
                         const char *             msg)
  :
    id_(header_store::get_new_id(this)),
    file_symbol_(symbol_store::get_symbol_id(file)),
    line_(line),
    func_symbol_(symbol_store::get_symbol_id(func)),
    level_(level),
    enabled_(enabled),
    msg_symbol_(symbol_store::get_symbol_id(msg))
  {
    header_.set_seqno(id_);
    header_.set_filenamesymbol(file_symbol_);
    header_.set_linenumber(line_);
    header_.set_functionnamesymbol(func_symbol_);
    header_.set_level(level_);
    header_.set_logstringsymbol(msg_symbol_);

    // merging in the LogParts message generated by signature
    auto pb_sig = sig.get_pb_header();
    if( pb_sig )
      header_.MergeFrom(*pb_sig);
  }

  void
  log_record::on_return() const
  {
    *this << end_msg();
  }
  
  bool
  log_record::enabled() const
  {
    return enabled_;
  }
  
  uint32_t
  log_record::id() const
  {
    return id_;
  }
  
  const interface::pb::LogHeader &
  log_record::get_pb_header() const
  {
    return header_;
  }
  
  
}}
